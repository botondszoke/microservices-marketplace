# Microservices-Based Containerized System Implementation / Mikroszolgáltatásokra épülő konténer-alapú rendszer megvalósítása
BME AUT Independent Laboratory - 2021/22/2 / BME AUT Önálló laboratórium - 2021/22/2  
Szőke-Milinte Botond - JQ162H   
Advisor: Dudás Ákos / Konzulens: Dudás Ákos

## Task Description / A feladat leírása
**EN**: The objective of this task is to develop a complex system focusing on the specificities of microservices architecture. I chose to implement a marketplace system. The application allows for user management, product creation, storage, grouping products with similar properties into categories, listing groups for sale (currently at a fixed price), and purchasing products. Upon a successful purchase, the system sends an email notification to the user. The application can be expanded with numerous functionalities in the future (e.g., product lifecycle tracking, writing reviews and ratings, implementing a proper payment system). The system backend runs in Docker containers, while the frontend is a separate web application implemented using React technology.

**HU**: A feladat célja egy komplex rendszer elkészítése a mikroszolgáltatások architektúra specialitásaira koncentrálva. Az alkalmazás témájának egy piactér (marketplace) rendszert választottam. A rendszerben lehetőség van felhasználókat kezelni, termékeket létrehozni, tárolni, csoportosítani az azonos tulajdonságú termékeket egy kategóriába, a csoportokat eladásra meghirdetni (egyelőre csak fix áron), illetve a termékeket megvásárolni. A sikeres vásárlásról a rendszer email értesítést küld a felhasználónak. Az alkalmazás a későbbiekben számos funkcionalitással bővíthető (pl. termék életútjának követése, vélemények és értékelések írása, rendes fizetési rendszer megvalósítása). A rendszer backendje Docker konténerekben fut, míg a frontend ettől külön található, egy React technológiával megvalósított weboldal.

## Architectural Structure / Architekturális felépítés
**EN**: Developing the system required learning and utilizing numerous technologies. The system consists of three custom-made microservices, and additional services run in containers to support the system's operation.

**HU**: A rendszer elkészítése során számos technológia megismerésére és felhasználására volt szükség. Három saját készítésű mikroszolgáltatás található a rendszerben, emellett a rendszer működéséhez további szolgáltatások futnak konténerekben.

### ProductService
**EN**: This service is responsible for managing products, storing their properties, and handling modifications. Structurally, it is a simple three-tier application backend containing the data access layer and business logic, with its services accessible via a REST API. It is implemented using ASP.NET 6 technology. Text data for products and product groups is stored in a containerized MongoDB database, while images associated with products are stored in the Blob Storage section of a containerized Azurite emulator. It is important to note that the Azurite emulator scales poorly and is not suitable for production environments. Therefore, it is advisable to switch to Microsoft Azure Blob Storage in the future, which scales well and conveniently allows for storing large binary data in the cloud. Additionally, since this service administers the change of product ownership during a purchase, it communicates with the EmailService, which subsequently sends an email notification. The REST API Swagger documentation is available at http://product.localhost.

**HU**: Ez a szolgáltatás felelős a termékek kezeléséért, tulajdonságaik tárolásáért és változtatásaiért. Felépítését tekintve egy egyszerű, háromrétegű alkalmazás backendjéről beszélhetünk, melyben helyet kap az adatelérési réteg, az üzleti logika, illetve REST API-n keresztül érhetőek el a szolgáltatásai. ASP.NET 6 technológiával került megvalósításra. A termékek és termékcsoportok szöveges adatait egy konténerizált MongoDB adatbázisban tárolja, míg a termékekhez tartozó képeket egy konténerizált Azurite emulátor Blob Storage részében. Fontos megjegyezni, hogy az Azurite emulátor rosszul skálázódik, production környezetben nem célszerű alkalmazni. Így a későbbiekben a Microsoft Azure Blob Storage-ra érdemes átállni, mely már jól skálázódik, kényelmesen lehetővé teszi nagyobb bináris adatok felhőben történő tárolását. Emellett, mivel ez a szolgáltatás adminisztrálja egy vásárlás során a termékek tulajdonosának megváltoztatását, ez a szolgáltatás lép kapcsolatba az EmailService-el, amely később email értesítést küld. A REST API Swagger dokumentációja elérhető a http://product.localhost címen.

### SaleService
**EN**: This service is responsible for allowing product groups to be listed for sale and stores data related to sales. Structurally, it is a simple three-tier application backend containing the data access layer and business logic, with its services accessible via a REST API. It is implemented using ASP.NET 6 technology. Sales-related data is stored in a MongoDB database. The REST API Swagger documentation is available at http://sale.localhost.

**HU**: Ez a szolgáltatás felelős azért, hogy meg lehessen hirdetni egy termékcsoportot eladásra, tárolja az eladáshoz kapcsolódó adatokat. Felépítését tekintve egy egyszerű, háromrétegű alkalmazás backendjéről beszélhetünk, melyben helyet kap az adatelérési réteg, az üzleti logika, illetve REST API-n keresztül érhetőek el a szolgáltatásai. ASP.NET 6 technológiával került megvalósításra. Az eladásokhoz kapcsolódó adatokat egy MongoDB adatbázisban tárolja. A REST API Swagger dokumentációja elérhető a http://sale.localhost címen.

### EmailService
**EN**: This service is responsible for notifying the user about predefined events in the form of an email message. It is written in Java and implemented using Spring Boot technology. The service is split into two containers. The EmailAPI container publishes a REST API through which it receives data for individual messages, constructs the email message, and places it into a message queue. The EmailService container monitors this message queue, retrieves messages when they appear, and sends the email. Email sending is realized via Gmail. The message queue is managed using RabbitMQ, which also runs in a container.

**HU**: Ez a szolgáltatás felelős azért, hogy előre felvett eseményekről értesítse a felhasználót egy email üzenet formájában. Java nyelven készült, Spring Boot technológiával került megvalósításra. A szolgáltatás két konténerre válik szét. Az EmailAPI konténer egy REST API-t publikál, melyen keresztül fogadja az egyes üzenetekhez tartozó adatokat, elkészíti az email üzenetet majd ezt egy üzenetsorba teszi bele. Az EmailService konténer pedig az előbbi üzenetsort figyeli, és ha üzenetet lát, kiveszi onnan, és elküldi az emailt. Az email küldése a Gmail-en keresztül valósul meg. Az üzenetsor kezelése a RabbitMQ segítségével zajlik, mely szintén egy konténerben fut.

### API Gateway
**EN**: An API Gateway has been implemented in the application, making all services accessible via a single entry point (in this case at http://localhost). It is responsible for routing HTTP requests to individual services, ensuring services are easily accessible, and hiding backend fragmentation from the client. The API Gateway is implemented containerized using the Traefik service, which allows necessary rules and settings to be described simply in the form of labels. It also provides the opportunity to integrate middleware on individual routers.

**HU**: Az alkalmazásban API Gateway került megvalósításra, így minden szolgáltatás elérhető egy belépési ponton (jelen esetben a http://localhost-on). Ez felelős a http kérések eljuttatásáért az egyes szolgáltatásokhoz, lehetőséget biztosít arra, hogy egyszerűen elérhetőek legyenek a szolgáltatások, elrejti a kliens elől a backend széttagoltságát. Az API Gateway a Traefik szolgáltatással, konténerizáltan került megvalósításra, mellyel egyszerűen, labelek formájában leírhatóak a szükséges szabályok, beállítások. Emellett lehetőséget biztosít middleware-ek beépítésére is az egyes routereken.

### User Management, Authentication / Felhasználókezelés, authentikáció
**EN**: User management is handled using the containerized Keycloak service. It enables simple registration and can be easily connected to frontend clients (e.g., the keycloak-js library is available for React and Angular), thus sparing other services from storing user-related data. It also provides the option to connect to other Identity Providers (Github, Google, Facebook, etc.), though this feature was not utilized during the project. The service connects to a containerized PostgreSQL database where it stores user management data.
Authentication is performed using the OAuth protocol. On the frontend client, this is simply handled by the associated keycloak-js library; for the backend, authentication is delegated to Traefik. To achieve this, a forwardauth middleware is attached to every service that may receive requests from a client, and identification is handled by a containerized `traefik-forward-auth` service. Due to the middleware, requests first arrive at this service. It checks if the user is logged in; if not, it redirects the user to the Keycloak login interface. Upon successful login, or if the user is already logged in, it simply adds an X-Forwarded-User header to the request containing the user ID. Thus, services receive an authenticated request, and the user ID is not provided by the client application.

**HU**: A felhasználókezelés a konténerizált Keycloak szolgáltatás segítségével történik. Egyszerű regisztrációt tesz lehetővé, és könnyen hozzákapcsolható a frontend kliensekhez (például Reacthoz és Angularhoz is elérhető a keycloak-js nevű segédkönyvtár), így megkíméli a többi szolgáltatást a felhasználókhoz kapcsolódó adatok tárolásától. Lehetőséget biztosít továbbá egyéb Identity Providerekhez történő kapcsolódásra is (Github, Google, Facebook stb.), ezt a lehetőséget azonban nem használtam még ki a projekt során. A szolgáltatás egy konténerizált PostgreSQL adatbázishoz kapcsolódik, ebben tárolja a felhasználókezeléshez kapcsolódó adatokat.
Az authentikáció OAuth protokoll segítségével történik. A frontend kliensnél ezt egyszerűen megoldja a kapcsolódó keycloak-js segédkönyvtár, a backend esetében az authentikáció a Traefikra van bízva. Ehhez minden szolgáltatáshoz, melyekhez kérés érkezhet egy klienstől, egy forwardauth middleware került kapcsolásra, az azonosítást pedig egy traefik-forward-auth konténerizált szolgáltatás felel. A middleware miatt a kérések először ehhez a szolgáltatáshoz érkeznek. Ez megvizsgálja, hogy be van-e lépve már a felhasználó, amennyiben nincs, átirányítja a felhasználót a Keycloak bejelentkező felületére, ahonnan bejelentkezhet. Sikeres bejelentkezés esetén, vagy már eredetileg is bejelentkezett felhasználó esetén csupán hozzáad egy X-Forwarded-User headert a kéréshez, melyben a felhasználó azonosítója található. Így a szolgáltatásokhoz már egy authentikált kérés érkezik, a felhasználó azonosítója pedig nem a kliens alkalmazás által lett megadva.

### Frontend
**EN**: A simple React-based web application is responsible for the application's display, using Material UI for tasteful formatting of individual components. It allows for performing all product-related operations, uploading images, listing prices, etc. This runs separately from the containerized environment and is accessible at http://localhost:3000. It is important to note that for the summary table of the user's products, it uses the MUI DataGridPro component, which is free for development purposes but requires purchasing a license for production environments (indicated by error messages in the console).

**HU**: Az alkalmazás megjelenítéséért egy egyszerű, React alapú webalkalmazás felelős, mely Material UI-t használ az egyes komponensek ízléses formázásához. Lehetőség van minden, a termékekhez kapcsolódó művelet elvégzésére, képek feltöltésére, azok árának meghirdetésére stb. Ez a konténerizált környezettől külön fut, a http://localhost:3000-es linken érhető el. Fontos megjegyezni, hogy a felhasználó termékeinek összesítő táblázatához a MUI DataGridPro komponensét használja, mely fejlesztési célokra ingyenesen használható, production környezetben azonban licensz megvásárlása szükséges (ezt a konzolban megjelenő hibaüzenetekkel is jelzi).

## Availability, Installation / Elérhetőség, telepítés
**EN**: The system source code is publicly available in the [https://github.com/botondszoke/microservices-marketplace](https://github.com/botondszoke/microservices-marketplace) repository. After cloning, it is highly recommended to replace the default names and passwords hardcoded for services and attach volumes to database containers. Then, the docker-compose file can be run. It is important to note that when containers start, the `traefik-forward-auth` container stops immediately. This is because although the Keycloak container has started, one must wait for the "Admin console listening on http://127.0.0.1:9990" message in its output to communicate with it. Restarting the container after this results in a successful connection. Following this, the Frontend can be started after running `npm install` and `npm start` commands.

**HU**: A rendszer forráskódja publikusan elérhető a [https://github.com/botondszoke/microservices-marketplace](https://github.com/botondszoke/microservices-marketplace) repositoryban. A klónozás után mindenképpen érdemes lecserélni az egyes szolgáltatásokhoz beégetett alapértelmezett neveket és jelszavakat, illetve volume-ot csatolni az adatbázisok konténereihez. Ezután a docker-compose fájl futtatható. Fontos megjegyezni, hogy a konténerek indulásakor a traefik-forward-auth konténer azonnal le is áll. Ennek az az oka, hogy bár a keycloak konténer elindult, ahhoz, hogy kommunikálni is lehessen vele, meg kell várni az „Admin console listening on http://127.0.0.1:9990” üzenetet a konténer kimenetén. Ezután ismét elindítva a konténert, a csatlakozás sikeresen megtörténik. Ezt követően elindítható a Frontend is az npm install és npm start parancsok kiadását követően.

## Development Opportunities / Fejlesztési lehetőségek
**EN**: The system can be further developed in numerous directions. Regarding functions, it would be worth adding an auction module, review options, lifecycle tracking, and naturally a proper payment system. On the sales listing page (and associated backend module), it would be advisable to implement a pagination system, as this significantly reduces load on both the client application and service in case of large data volumes, and speeds up network communication. Communication with and within the system occurs via HTTP protocol (except for the email service's message queue communication); this should definitely be replaced with HTTPS protocol in a production environment, and a valid certificate should be obtained. Additionally, as mentioned above, the Azurite emulator needs to be replaced with the scalable Azure Blob Storage, and a license must be purchased for the MUI DataGridPro component if aiming for a production deployment.

**HU**: A rendszer számos irányban továbbfejleszthető. Funkciók tekintetében érdemes lehet hozzáadni aukciós modult, véleményezési lehetőséget, életút követést és természetesen a megfelelő fizetési rendszert is. Az eladásokat listázó oldalon (és a kapcsolódó backend modulban) célszerű lenne lapozásos rendszert kialakítani, hiszen nagy mennyiségű adat esetén ez jelentősen csökkenti mind a kliens alkalmazás, mind a szolgáltatás terheltségét, továbbá a hálózati kommunikációt is gyorsítja. A rendszerrel való kommunikáció, és a rendszer belső kommunikációja HTTP protokollal történik (kivéve az email szolgáltatás üzenetsoros kommunikációját), ezt mindenképpen érdemes production környezetben HTTPS protokollra cserélni, és érvényes tanúsítványt beszerezni. Emellett, ahogyan az fentebb olvasható, az Azurite emulátort szükséges lecserélni a jól skálázható Azure Blob Storage-ra, illetve licenszt kell vásárolni a MUI DataGridPro komponenshez, amennyiben production környezetbe szeretnénk helyezni a rendszert.
